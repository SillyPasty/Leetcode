# 面试

## 自我介绍

- 面试官您好，我叫王宇博，来自北京邮电大学国际学院物联网专业，现在是大二在读。自己平时性格很开朗，比较自来熟。也对编程特别有兴趣，自己也喜欢用编程去解决一些实际生活中的问题。这次来面试的岗位是后端开发实习生这样一个岗位，是在北邮人论坛上了解到的招聘信息，因为自己最近也在做web后端的项目，加上自己也在做这方面的准备。也很荣幸能获得这次面试的机会。

## 基础知识

### 语言

#### Python

##### 语言基础

- GIL： 全局解释器锁，它确保任何时候都只有一个Python线程执行。

  - 使该进程内的其他线程无法运行，该线程运行完之后其他线程才能运行，多线程中，线程的运行依然有先后顺序，不能同时进行。
  - 多进程每个进程都能被系统分配资源，相当于每个进程有一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。

- func(*args, **kwargs)中的\*arg和\*\*kwarg

  - *arg：将不定长度的非键值对参数列表传递给一个函数
  - **kwarg：将不定长度的键值对传给一个参数

- 设计模式

  - 单例模式：一个类仅有一个实例，并提供一个访问它的全局访问点，比如框架中的数据库连接
  - 装饰器模式：不修改源代码和继承的情况下动态扩展类的功能
  - 迭代器模式：提供一个方法顺序访问一个聚合对象中的各个元素
  - 命令模式

- 垃圾回收

  python解释器对正在使用的对象保持计数，当某个对像的引用计数降为0时，垃圾收集器就可以释放该对象，获取分配的内存。当分配对象和取消分配对象的差值高于阈值时垃圾回收才会启动。

  分代回收：python将所有的对象分为0,1,2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

- 编码和解码

  - 数据通过编码decode转换成unicode编码，编码的同时会将数据变成byte类型，通过encode解码

- 装饰器

  - 在代码运行期间动态增加功能的方式，一个返回函数的高阶函数 

    ```python
    def log(func):
        def wrapper(*args, **kw):
            print('call %s():' % func.__name__)
            return func(*args, **kw)
        return wrapper
    ```

    ```python
    @log
    def now():
        print('2015-3-25')
    ```

  - 如果decorator本身需要传入参数，需要编写一个返回decorator的高阶函数

  - 什么样的语言能够使用装饰器？

    函数可以作为参数传递的语言

- 面对对象

  - __new\_\_和\_\_init\_\_的区别

    init是初始化方法，在创建object时被调用。new需要一个cls参数，代表当前类，需要有返回值，返回实例化出来的类

  - __str\_\_和\_\_del\_\_

- map(*func*, *list*)函数

- 列表

  - 可变长度的数组

- 字典

  - 键值配对组成的元素集合，是一个可变容器模型。字典的实现和哈希算法密不可分
  - 3.7+字典是有序的
  - 3.6
    - 底层维护一张哈希表，若哈希冲突，向下寻找空位置。
    - 底层是会动态扩展长度的，每一次扩展长度，都会重新计算所有key的hash值
  - 3.7
    - 除了hash，使用了一张indices来辅助
  - 需要是可hash的，列表不行

- 生成随机数

  `random.randint(a, b)   random.random()`

- 数据类型

  - 不可变

    字符串型，元组，数值型

    若改变，新建了一个对象

  - 可变

    列表、字典。列表和字典的一些操作。

- 去重：使用set

- lambda

  `sum=lambda a,b:a*b`

- collections库

- 正则表达式

  - `re.compile`作用

    正则表达式编译为一个对象，重复使用

- 自定义异常使用raise抛出异常

- `x.join()`

- `zip()`以一个/多个可迭代对象作为参数，返回一个元组的列表，传参数长度不同时，以最短序列长度为准进行截取

- `.encode()`

- 单例模式：利用__new\_\_

  ```python
  class A:
      instance = None
      def __new__(cls, *args, **kwargs):
          if cls.instance is None:
              cls.instance = super().__new__(cls)
          return cls.instance
  ```

- copy和deepcopy

- PEP8编码规范

- 传参

  - 引用传递
  - 不可变类型不会影响
  - 可变类型会更改传入变量
  
- 事件驱动

  - 每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
  
- Import

  - 包：一个文件夹下有__init\_\_.py时，为一个包，包内为模块

##### Flask

- Python编写的web为框架

- Flask蓝图

  - 模块化应用

- SocketIO

  使 Flask 应用程序能够访问客户端和服务器之间的低延迟双向通信
  
- WSGI

  底层代码由服务器软件实现，不用接受、解析HTTP请求，发送HTTP响应

##### Celery

- 分布式任务队列

- 架构

  - 生产者Producer

    调用了celery提供的API、函数、装饰器产生任务并交给任务处理队列。

  - 消息中间人Broker

    即主程序将任务放入队列中，而后台职程则会从队列中取出任务并执行。任务可以按顺序调度，也可以按计划时间调度。

  - 任务执行单元Worker

    执行任务的程序，可以有多个并发。实时监控消息队列，获取队列中调度的任务

  - 执行结果储存Backend

    由于任务的执行同主程序分开，如果主程序想获取任务执行的结果，就必须通过中间件存储。同消息中间人一样，存储也可以使用RabbitMQ、Redis、MongoDB、SQLAlchemy、Memcached等，建议使用带持久化功能的存储中间件。另外，并非所有的任务执行都需要保存结果，这个模块可以不配置。

- 序列化方案

  - 什么是序列化？ 把变量从内存中变成可储存或传输的过程为序列化。
  - json
  - yaml

##### SQLAlchemy

- 是Pyhon编程语言下的一块开源软件，提供了SQL工具包以及对象关系映射工具。
- SQL对象关系映射(ORM)的工具，更为直观。

#### Golang

##### 语言基础

- 并发编程方面比较简洁

- 不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。

  协程被理解成轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。一般由应用程序显式实现调度，上下文切换不需要下到内核层。没有切换线程开销，在处理大规模并发连接时，协程要优于线程。协程不需要多线程的锁机制。
  
- goroutine的调度

  - goroutine是轻量级的**线程**或者称为**协程**，切换时并不必陷入到操作系统内核中，所以保存过程很轻量
  - go 关键字 创建一个goroutine

- go defer

  - 函数返回之前进行调用，调用顺序类似栈
  - 坑：return不是原子指令

- go slice 原理

  - 内存中，包含三个域的结构体
    - 第一个元素的指针
    - slice长度
    - slice容量
  - 动态数组的实现
    - 新的大小是当前大小2倍以上，扩容增长为新的大小
    - if 小于 1024， 2倍增长，否则按照为当前大小1/4增长

- go make 和 new

  - new 返回一个指针，指向已清零内存
  - make 返回一个结构，内部会有隐式的指针

- go map 原理

  - 哈希表实现，大小是2的指数倍
  - 不是将旧的数据全部换到新的位置，逐步完成，有一个新的表和一个旧的bucket

- go panic

  - 处理完当前goroutine已经defer的任务

  - 可以在defer中使用recover来捕捉panic

  - e.g.

    - ```go
      package main
      
      import (
      	"os"
      	"fmt"
      	"time"
      )
      
      func main() {
      	defer fmt.Println("defer main") // will this be called when panic?
      	var user = os.Getenv("USER_")
      	go func() {
              defer func() {
                  fmt.Println("defer caller")
                  if err := recover(); err != nil {
                      fmt.Println("recover success.")
                  }
              }()
              func() {
                  defer func() {
                      fmt.Println("defer here")
                  }()
      
                  if user == "" {
                      panic("should set user env.")
                  }
                  fmt.Println("after panic")
              }()
      	}()
      
      	time.Sleep(1 * time.Second)
      	fmt.Printf("get result %d\r\n", result)
      }
      ```

    

- Go channel

  - 一个数据结构

    - `ch <- v`
    - `v:= <- ch`
    - `ch := make(chan int, 100)`

  - e.g.

    - ```go
      import "fmt"
      func sum(s []int, c chan int) {
      	sum := 0
      	for _, v := range s {
      		sum += v
      	}
      	c <- sum // send sum to c
      }
      func main() {
      	s := []int{7, 2, 8, -9, 4, 0}
      	c := make(chan int)
      	go sum(s[:len(s)/2], c)
      	go sum(s[len(s)/2:], c)
      	x, y := <-c, <-c // receive from c
      	fmt.Println(x, y, x+y)
      }
      ```

  - select 类似 if else if

    - ```go
      import "fmt"
      func fibonacci(c, quit chan int) {
      	x, y := 0, 1
      	for {
      		select {
      		case c <- x:
      			x, y = y, x+y
      		case <-quit:
      			fmt.Println("quit")
      			return
      		}
      	}
      }
      func main() {
      	c := make(chan int)
      	quit := make(chan int)
      	go func() {
      		for i := 0; i < 10; i++ {
      			fmt.Println(<-c)
      		}
      		quit <- 0
          }()
      	fibonacci(c, quit)
      }
      ```

  - 缓冲区

  - 定时器

    - ```go
      timer1 := time.NewTimer(time.Second * 2)
      <-timer1.C
      fmt.Println("Timer 1 expired")
      ```

    - ```go
      ticker := time.NewTicker(time.Millisecond * 500)
      go func() {
      	for t := range ticker.C {
      		fmt.Println("Tick at", t)
      	}
      }()
      ```

  - 生产者-消费者模式

  - 线程同步

    - ```go
      import (
      	"fmt"
      	"time"
      )
      
      func worker(done chan bool) {
      	time.Sleep(time.Second)
      
      	// 通知任务已完成
      	done <- true
      }
      
      func main() {
      	done := make(chan bool, 1)
      	go worker(done)
      
      	// 等待任务完成
      	<-done
      }
      ```

- go 锁

### 数据结构

#### 树

- 红黑树

- B树

- B+树

  B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

  - B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加；
  - B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
  - B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针；
  - 非叶子节点的子节点数=关键字数； 
  - 优点
    - 层级更少，非叶子存储的关键字数更多
    - 查询速度更加稳定
    - 天然排序功能，所有的叶子节点数据构成了一个有序链表
    - 全节点遍历更快

#### 哈希表

- 哈希函数
- 哈希冲突
  - 链地址法
  - 开放定址
  - 再哈希
- 扩容
  - 根据加载因子进行扩容
- 设计

### 计算机网络

#### 五层协议

- 应用层：通过应用进程间的交互来完成特定的网络应用，应用层交互的数据单元成为报文
  - DNS、HTTP
- 传输层：负责向两台主机进程之间的通信提供通用的数据传输服务
  - TCP、UDP协议
- 网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。
  - IP协议
- 数据链路层：物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，向网络层提供高质量的数据传输服务。
- 物理层

#### TCP协议

- 基于传输层的协议，提供面向连接的服务，保证数据的传递

- 三次握手

  - 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
  - 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
  - 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

- 四次挥手

  - 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
  - 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
  - 服务器-关闭与客户端的连接，发送一个FIN给客户端
  - 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

- TCP与UDP协议的区别

- | 类型 | 是否面向连接 | 传输可靠性 | 传输形式   | 传输效率 | 所需资源 | 应用场景     |
  | ---- | ------------ | ---------- | ---------- | -------- | -------- | ------------ |
  | TCP  | 面向连接     | 可靠       | 字节流     | 慢       | 多       | 通信数据可靠 |
  | UDP  | 无连接       | 不可靠     | 数据报文段 | 快       | 少       | 通信速度高   |

- 如何保证可靠传输

  - 校验和

    在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和

  - 序列号和确认应答

    TCP传输时将每个字节的数据都进行了编号，这就是序列号，序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证，

  - 超时重传

    发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。最大超时时间-动态计算

  - 连接管理

  - 流量控制

    滑动窗口

  - 拥塞控制

    TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。

    拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。

- 滑动窗口

  - TCP 利用滑动窗口实现流量控制的机制。
  - 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。
  - TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

#### 打开一个网页的过程

| 过程                              | 使用的协议 |
| --------------------------------- | ---------- |
| 浏览器查找域名的IP地址            | DNS        |
| 浏览器向web服务器发送一个HTTP请求 | TCP        |
| 服务器处理请求                    | IP         |
| 服务器发回一个HTML响应            |            |
| 浏览器开始显示HTML                | HTTP       |

![各种协议与HTTP协议之间的关系](https://user-gold-cdn.xitu.io/2018/5/8/1633ead316d07713?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### REST接口

- 用URL定位资源，用HTTP表示操作
- URI命名原则上不使用动词
- 用一套公共的接口为前端提供服务

#### 同源策略

- 协议相同
- 域名相同
- 端口相同

#### Cookie和Session

- 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- session在服务端，cookie在客户端(浏览器)
- session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效，存储Session时，键与Cookie中的session id相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置。
- cookie安全性比session差

#### Socket

- 套接字 Socket是对TCP/IP协议的封装，把复杂的TCP/IP协议隐藏在接口后面，是一个API

- 建立Socket连接

  建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。

  - 服务器监听
  - 客户端请求
  - 连接确认

- 长连接的心跳包

  为了避免一个连接长时间不活跃被关闭而定时发送的一个骚扰包

  防止节点中的防火墙、路由器、网关断掉连接。

#### HTTP

- 超文本传输协议，用于传输超媒体文档的应用层协议。是为了web浏览器与web服务器之间的通信设计的。

- HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西

- 常见请求

  - GET

  - PUT

  - PATCH

    对已知资源进行局部更新

  - POST
  
  - DELETE
  
  - GET和POST的请求区别
  
    - GET请求是通过URL直接请求数据，数据信息可以在URL中直接看到，比如浏览器访问；而POST请求是放在请求头中的，无法直接看到的
  
- GET提交有数据大小的限制，一般是不超过1024个字节，而这种说法也不完全准确，HTTP协议并没有设定URL字节长度的上限，而是浏览器做了些处理，所以长度依据浏览器的不同有所不同；POST请求在HTTP协议中也没有做说明，一般来说是没有设置限制的，但是实际上浏览器也有默认值。总体来说，少量的数据使用GET，大量的数据使用POST。
  
  - GET请求因为数据参数是暴露在URL中的，所以安全性比较低，比如密码是不能暴露的，就不能使用GET请求；POST请求中，请求参数信息是放在请求头的，所以安全性较高，可以使用。在实际中，涉及到登录操作的时候，尽量使用HTTPS请求，安全性更好。
  
- 缓存

  - 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。
  - 私有缓存只能适用于单独用户。
  - 共享缓存可以被多个用户使用。

- HTTP中常见的请求头

  - accept   浏览器接受的数据类型
  - host：当前请求访问的目标地址
  - user-agent： 浏览器类型
  - connection：浏览器跟服务器连接状态
  - cookie：浏览器保存的cookie信息
  
- 响应头

  - server：服务器类型
  - content-type：服务器发送给浏览器的数据类型及内容编码
  - Last-Modified：服务器资源最后的修改时间
  - expires 通知浏览器缓存
  - set-cookie：表示服务器发送给浏览器的cookie信息

- 状态码

  | **状态码** |                           | **意义**                                 |
  | :--------- | ------------------------- | ---------------------------------------- |
  | **200**    | **OK**                    | **请求正常处理完毕**                     |
  | 204        | No Content                | 请求成功处理，没有实体的主体返回         |
  | 206        | Partial Content           | GET范围请求已成功处理                    |
  | **301**    | **Moved Permanently**     | **永久重定向，资源已永久分配新URI**      |
  | 302        | Found                     | 临时重定向，资源已临时分配新URI          |
  | 303        | See Other                 | 临时重定向，期望使用GET定向获取          |
  | **304**    | **Not Modified**          | **发送的附带条件请求未满足**             |
  | 307        | Temporary Redirect        | 临时重定向，POST不会变成GET              |
  | **400**    | **Bad Request**           | **请求报文语法错误或参数错误**           |
  | 401        | Unauthorized              | 需要通过HTTP认证，或认证失败             |
  | **403**    | **Forbidden**             | **请求资源被拒绝**                       |
  | **404**    | **Not Found**             | **无法找到请求资源（服务器无理由拒绝）** |
  | **500**    | **Internal Server Error** | **服务器故障或Web应用故障**              |
  | 503        | Service Unavailable       | 服务器超负载或停机维护                   |

- 长连接和短连接

  - HTTP/1.0中默认使用短连接

    每进行一次HTTP操作，就建立一次连接，任务结束就中断连接

  - HTTP/1.1中默认使用长连接

    TCP连接不会关闭，响应头会加一行connection: keep-alive
  
- HTTP2.0

  - 同域名下所有通信都在单个连接上完成。
  - 单个连接可以承载任意数量的双向数据流。
  - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。
  
- HTTPS

    - 对数据加密，建立一个信息安全通道
    
    - 先和SSL通信，再由SSL和TCP通信。
    
      Secure Socket Layer

### 数据库

#### 基础知识

- ACID

  - 原子性

    事务是最小的执行单位，要么全部完成，要么全部不起作用

  - 一致性 consistency

    执行事务前后，数据保持一致，多个事务对同一个数据的读取结果是相同的

  - 隔离性

    并发访问数据库是，一个用户的事务不被其他事务干扰，各并发事务之间数据库是独立的

  - 持久性

    一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

- 并发事务

  - 脏读

    当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

  - 丢失修改

    指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

  - 不可重复读

    指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读

- 三个范式

  - 第一范式

    数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

  - 第二范式

    数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。

  - 第三范式

    在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y。
  
- ER图

  - Entity attribute relationship

#### MySQL

- 特点

  - 关系型数据库管理系统
  - 数据存放在不同的表中
  - 多种语言的接口

- 数据类型

  - 整数类型

    包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。

  - 实数类型

    包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。

  - 字符串类型

    包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。VARCHAR存储的内容超出设置的长度时，内容会被截断。CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR会根据需要使用空格进行填充方便比较。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。CHAR存储的内容超出设置的长度时，内容同样会被截断。

  - 日期和时间类型

    尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。

- 索引

  - 索引分为两大类：聚簇索引和非聚簇索引。聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引则不同；聚簇索引能够提高多行检索的速度，而非聚簇索引则对单行的检索速度很快。

  - 将无序对变为有序对

  - B+Tree索引，可以用类似二分查找的形式找到对应的页

  - 最左前缀原则

    - 检索数据时从联合索引的最左边开始匹配
    - (col1, col2, col3)联合索引
    - 匹配时，实际有col1 和 (col1, col2), (col1, col2, col3)三个索引

  - 添加索引

    PRIMARY KEY `ALTER TABLE 'table_name' ADD PRIMARY KEY ('column')`

    唯一索引`ALTER TABLE 'table_name' ADD UNIQUE ('column')`

    普通索引`ALTER TABLE 'table_name' ADD INDEX index_name ( 'column' )`

  - 大大减少服务器需要扫描的数据量。

  - 帮助服务器避免排序和临时表。

  - 将随机I/O变顺序I/O。

  - 大大提高查询速度。

- 基本存储结构

  - 页
  - 数据页可以组成一个双向链表

- 触发器

  - 一段代码触发某个事件时，自动执行这些代码

- 常用数据存储引擎

  - InnoDB：

    支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。

    - 事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
    - 外键 行锁 不支持全文索引 支持崩溃后的恢复

  - Memory：

    所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

  - MyISAM：

    插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。

    - 表锁

- 乐观锁和悲观锁

  - 悲观锁

    每次拿取数据都会上锁，共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。行锁、表锁、读写锁。

  - 乐观锁

    拿去数据不会修改，更新的时候会判断一下有没有人取更新这个数据。通过版本号判断。

- 版本号

- 锁机制

  - 表级锁：粒度最大，加锁快，不会出现死锁。并发度较低，触发锁冲突的几率较高。
  - 行级锁：粒度最小，只针对当前操作的行进行加锁，并发度高，开销大，会出现死锁。

- 大表优化

  - 限定数据范围
  - 读写分离
  - 垂直分区：根据数据库内数据表的相关性进行拆分
  - 水平分区：数据表的结构不变，通过某种策略储存数数据分片，达到了分布式的目的。

- 数据库分片

  - 客户端代理：分片逻辑在应用端
  - 中间件代理：应用和数据中间加了一个代理层

#### Redis

- 用C语言写成的，开源的key-value数据库
- 好处
  - 速度快，数据存在内存中，类似于HashMap
  - 支持丰富数据类型
  - 支持事务，redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。
  - 丰富的特性
  - 单线程，不需要加锁
- 数据类型
  - String: key-value类型
  - Hash: Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。
  - List: 双向链表，支持反向查找和遍历，更方便操作。
  - Set: 自动排重
  - Sorted set: 有序排列
- 数据淘汰策略
  - volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
  - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
  - allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
  - allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
  - no-enviction（驱逐）：禁止驱逐数据
- 并发竞争问题

### 操作系统

#### Linux

- IO模式

  - 阻塞I/O

    准备数据，等待数据的到达(收到一个完整的包)，进程被阻塞，等到数据好了，才会返回结果，用户进程才解除block的状态。

  - 非阻塞I/O

    当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

  - I/O多路复用

  - 异步I/O
  
- ctrl-c 向终端发送SIGINT信号，常用于中止正在运行的程序

- ctrl-z 向中断发送SIGSTOP信号，常用于挂起一个进程

#### 线程与进程

- 进程
  - 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立
  - 稳定性好，一个进程崩溃不会影响其他进程
  - 消耗资源大，开启的进程数量有限制
- 线程
  - CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源
  - 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃

#### 进程间的通信

- 管道/匿名管道：数据只能向一个方向流动，只能用于具有亲缘关系的进程之间
- 有名管道：可以完成无血缘关系的进程间通信
- 信号
- 消息队列
- 套接字

#### 进程间的同步

- 父进程

### 软件工程

#### MVC

- model-view-controller
- 控制器：负责转发请求，对请求进行处理
- 视图：图形界面设计
- 模型：实现算法、与数据库的交互

## 工具知识

### Kafka

- 一个分布式流式处理平台
  - 消息队列：发布和订阅信息流
  - 容错的持久方式储存记录消息流
  - 流式处理平台

#### 概念

- 生产者和消费者

- Topic
  - 每个topic对应一个消息队列
- Partition
  - 对topic的水平扩展
  - 一般来说，每一个partition对应一个consumer
    - Consumer的数量不能超过partition
  - partition分配策略
  - 只保证消息在partition内部是有序的，不管全局情况
  - 为每个consumer group保存一个偏移量
- Broker
  - 一个Kafka服务器
- Cluster
  - 若干个broker组成一个cluster
  - 一个broker成为集群控制器
  - 可以有多个冗余

#### 为什么效率高

- 储存在文件之上，每个partition为一个目录
  - 操作系统的预读与后写
  - 顺序磁盘读写效率较高

### Nginx

## 面经

### 今日头条

#### 2020.5.19

##### 一面

- 自我介绍
- 基础知识
  - 语言
    - PYTHON装饰器  写一个打印时间和函数名字的装饰器
    - GIL
    - Celery
  - 数据库
    - Redis
    - InnoDB和MyISAM的区别
    - MySQL索引，索引匹配原则
    - 设计索引
    - 联合索引
  - 计网
    - HTTP协议
    - TCP协议
    - TCP为什么可靠
- 算法题
- 动态规划，硬币最小数
- 入职时间
- 有什么问题



##### 二面

- 自我介绍
- 项目介绍
- 项目细节
- 基础知识
  - 语言
    - PYTHON和GO的区别
    - celery 底层实现 套接字
  - 数据库
    - MySQL中，INSERT会不会加锁，SELECT会不会加锁
  - 网络
    - TCP四次挥手
    - 如果页面卡顿，如何定位错误
    - session跨主机
  - 操作系统
    - Linux 同步I/O 异步I/O 阻塞I/O等等
    - 进程间通信方式
    - 进程间通讯
    - linux监听端口
  - 系统设计
    - 并发系统设计
- 算法题
  - 动态规划 大于等于K的窗口
  - 用栈实现队列
- 入职时间
- 有什么问题

#### Byte Camp 2020-08-09

- 1小时
- 自我介绍
- 项目简介
- 操作系统
  - 进程与线程区别
  - 进程间同步方法
  - 死锁/如何避免
- 计网
  - TCP/UDP 区别
  - 三次握手
- 数据库
  - 索引
    - B+树
  - 缓存
    - redis

- 语言
  - python 内存管理
  - 多线程
  - lambda
  - python is 和 == 的区别
- 算法
  - 一个随机数生成器
    - p : 0, 1-p: 1
    - 如何一个50% 50%
  - 购买股票的最好时机 三道变种 dp

